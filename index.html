<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>GMpj</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="GMpj">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="GMpj">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GMpj">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="GMpj" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">GMpj</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java并发编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/22/java并发编程/" class="article-date">
  <time datetime="2016-12-22T14:04:00.000Z" itemprop="datePublished">2016-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/java并发编程/">java并发编程一（资源访问控制）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>并发编程，是指通过多个线程之间的相互配合来实现一定的功能。因此多线程之间的控制（资源请求控制，线程执行控制）是实现并发编程的基础。</p>
<hr>
<h2 id="多线程的资源访问控制"><a href="#多线程的资源访问控制" class="headerlink" title="多线程的资源访问控制"></a>多线程的资源访问控制</h2><p>首先我们先看一下多线程之间的资源访问控制。</p>
<p>程序中的资源被经过一些操作可以得到我们想要的结果，当资源只被一个线程所执行，或者线程的操作不依赖于资源的上下文时，资源的处理结果一般都是可靠的，否则往往会出现意想不到的结果。</p>
<p>我们可以通过以下几种方式对资源的操作进行控制。</p>
<hr>
<h2 id="1-让资源不可变"><a href="#1-让资源不可变" class="headerlink" title="1.让资源不可变"></a>1.让资源不可变</h2><p>当资源是不可变的时候，程序也就无法对它进行操作，自然也不会出现线程安全问题。</p>
<p>对于在访问和更新相关变量时出现的竞争条件问题，可以通过这些将这些变量全部保存在一个不可变对象中来消除问题。</p>
<p>满足以下条件的对象才是不可变的：<br>1）对象创建以后其状态就不能修改<br>2）对于的所有域都是final类型<br>3）对象是安全创建的（在对象的创建期间，this引用没有逸出）</p>
<hr>
<h2 id="2-将资源封闭在线程内"><a href="#2-将资源封闭在线程内" class="headerlink" title="2.将资源封闭在线程内"></a>2.将资源封闭在线程内</h2><p>如果一个资源的创建到消失，都在一个线程内部的话，其他的线程也就无法对它进行操作，这样就保证了线程操作结果的可靠性。这种技术称之为线程封闭。</p>
<p>线程封闭的技术一个常见的应用场景是JDBC的Connection对象，在典型的服务器应用程序中，线程从连接池获得一个Connection对象，然后使用该对象处理请求，使用完后再返还给连接池。由于大多数请求（例如Servlet或者EJB调用）都是又单个线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会将它再分配给其他的线程，因此，这种处理方式保证了Connection的线程安全。</p>
<p>有以下三种方式实现线程封闭。</p>
<hr>
<h2 id="2-1Ad-hoc线程封闭"><a href="#2-1Ad-hoc线程封闭" class="headerlink" title="2.1Ad-hoc线程封闭"></a>2.1Ad-hoc线程封闭</h2><p>Ad-hoc线程封闭式指，维护线程封闭性的职责完全由程序来承担。Ad-hoc线程封闭式非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或者局部变量，能将对象封闭到模板线程上。因此在程序中使用的非常少。</p>
<hr>
<h2 id="2-2栈封闭"><a href="#2-2栈封闭" class="headerlink" title="2.2栈封闭"></a>2.2栈封闭</h2><p>栈封闭式线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，其他线程无法访问这个栈。</p>
<p>需要注意的是，在维持栈封闭时，需要注意被引用的对象不能逸出。因此编码人员在编写代码时，对于不能逸出的对象要特别进行标明，防止后续的维护人员错误的使对象逸出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span></span>&#123;</span><br><span class="line">		List&lt;Animal&gt; animals;</span><br><span class="line">		<span class="keyword">int</span> numPairs=<span class="number">0</span>;</span><br><span class="line">		 Animal candidate=<span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		animals=<span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">		animals.addAll( candidates);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(Animal a:animals)&#123;</span><br><span class="line">			numPairs=numPairs+a.getPairs();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> numPairs;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，无论如何操作animals都不会对其他线程造成影响，每个线程维护自己的变量，但是如果发布了animals的引用，那么就会造成对象的逸出，其他线程对该引用进行操作时，就会造成这个程序的错误。</p>
<hr>
<h2 id="2-3ThreadLocal类"><a href="#2-3ThreadLocal类" class="headerlink" title="2.3ThreadLocal类"></a>2.3ThreadLocal类</h2><p>维护线程封闭性的更规范的方法是使用ThreadLocal，这个类能使线程中某个值与保存值得对象关联起来。ThreadLocal提供了get和set等访问接口或者方法，这些方法为每个使用该变量的线程都有一个独立的副本，因此get总是返回当前执行线程在调用set时设置的最新值。</p>
<p>ThreadLocal对象通常用于防止对可变的单例实例变量或者全局变量进行共享。例如，在单线程应用程序中可能会维护一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都需要传播一个Connection对象。由于JDBC的连接对象不一定是线程安全的。因此，当多线程应用程序在没有协调的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLoacl对象中，每个线程都会拥有属于自己的连接，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder =</span><br><span class="line">			<span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> DriverManager.getConnection(url);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>当某个程序初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。从概念上看，可以将ThreadLocal<t>视为包含了Map<thread,t>对象，其中保存了特定于该线程的值，但ThreadLocal的实现并非如此。这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。<br>当某个频繁执行的操作需要一个临界对象，例如一个缓冲区，而同时有希望避免在每次执行时都重新分配该临界对象，就可以使用这项技术。</thread,t></t></p>
<p>假设需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转移为ThreadLocal对象，可以维护线程安全性。然而，如果将应用程序范围内的缓存转换为线程局部的缓存，就不会有太大的作用。</p>
<p>在实现应用程序框架时大量使用了ThreadLocal。例如，在EJB的调用期间，J2EE容器需要将一个事务上下文与某个执行中的线程关联起来。通过将事务上下文保存在静态的ThreadLocal对象中，就可以很容易实现这个功能：当框架代码需要判断当前运行的是哪一个事务时，只需要从这个ThreadLocal对象中读取事务的上下文。这种机制很方便，因为它避免了在调用每个方法时都传播上下文信息，然而这也将是用该机制的代码与框架耦合在一起。</p>
<p>ThreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p>
<hr>
<h2 id="3-安全发布对象"><a href="#3-安全发布对象" class="headerlink" title="3.安全发布对象"></a>3.安全发布对象</h2><p>前面讲了安全访问对象的一些办法，但是对象安全访问并不能保证对象一定是安全的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  Holder holder;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">		holder=<span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>上述这段代码即使在初始化过程中正确构建了不变性的条件在多线程状态下运行会发生错误，这是由于可见性的问题，其他线程可能看到尚未创建好完整的Holder对象。这样不安全的发布对象将造成，除了发布对象外，其他线程看到的Holder域是一个空引用或者是之前的值，或者，线程看到的Holder引用的值是最新的，但是状态值是失效的，更加严重的是，线程第一次看到的状态值是失效的，第二次读取时得到更新值，这个时候就会发生错误。因此对于对象不仅要安全的引用，还要安全的发布。</p>
<p>如果上述Holder域是不可变的，那么即使没有安全的发布，程序也不会发生错误。对于不可变对象来说，Java内部模式提供了特殊的初始化保证，即使对象没有安全的发布，对象仍然可以安全的访问。</p>
<p>可以通过以下几步构造一个不可变的对象：<br>1）将类声明为final，所以它不能被继承；<br>2）将所有的成员声明为私有的，这样就不允许直接访问这些成员；<br>3）对变量不要提供setter方法；<br>4）将所有可变的成员声明为final，这样只能对它们赋值一次；<br>5）通过构造器初始化所有成员，进行深拷贝（deep copy）；<br>6）在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝；</p>
<p>如果想要安全的发布一个对象，那么对象的引用以及对象的状态必须同时对于其他线程可见。</p>
<p>一个正确构造的对象可以通过以下几种方式进行发布：<br>1.在静态初始化函数中初始化一个对象的引用，最简单的方法就是使用静态的初始化器。<br>2.将对象的引用保存到volatile类型的域或者AtmicReferance对象中。<br>3.将对象的引用保存到某个正确构造对象的final类型域中。<br>4.将对象的引用保存到一个由锁保护的域中。</p>
<p>java容器中有一些特别的容器，可以保证存放在里面的对象可以安全的发布。它们分别是HashTable、synchronizedMap、ConcurrentMap、Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList、synchronizedSet、BlockingQueue以及ConcurrentLinkedQuene。</p>
<p>如果一个对象在发布之后从技术上看是可变的，但是其状态在发布之后不会再改变，那么把这种对象称之为事实不可变对象，对于这种对象，只要能够安全发布即可。通过使用事实不可变对象，即能够简化开发还能够提高程序性能。</p>
<p>如何对象是可变的，那么不仅要在发布的时候使用同步，在访问的时候同样需要同步来保证后续操作的可见性。</p>
<p>因此，对象的发布取决于它的可变性：<br>1.不可变的对象可以通过任意的机制发布。<br>2.事实不可变的对象必须通过安全方式来发布。<br>3.可变对象必须通过安全方式来发布，并且对象的操作必须是线程安全的或者由某个锁保护起来。</p>
<p>在并发程序中使用和共享对象时，可以使用一些实用的策略来保证对象的正确性：<br>1.线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在线程中，只能由这个线程修改。<br>2.只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但是任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。<br>3.线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过公有接口来进行访问而不需要进一步的同步。<br>4.保护对象。被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其他线程安全对象中的对象，已经已经发布的并且由某个特定锁保护的对象。</p>
<p>除了对资源的访问控制，也可以对线程的执行进行控制。</p>
<p>大多数的并发应用程序都是围绕“任务执行”来进行构造的，在理想情况下，各个任务之间是相互独立的，任务并不依赖于其他任务的状态、结果和边界效应。越高的独立性越有助于实现并发，因为在足够多的处理资源情况下，这些独立的任务都可以并行的执行。在正常负载的情况下，为每个任务分配一个线程的方法能够提升串行执行的性能。但是实际情况中，这种方法有着很严重的缺陷，尤其是需要创建大量线程时，因为线程生命周期的开销非常高，尤其是在请求量很高，但是处理过程是轻量的情况下，将浪费大量额计算资源。另外如果可运行的线程数量多于可用处理器的数量，那么有些线程将闲置，大量空闲的线程会占用很多内存，给垃圾回收器带来压力。另外一个问题是可创建线程的数量存在一个闲置，这个闲置受到平台操作系统，JVM等环境的影响。因此我们需要使用一定的策略来对线程的创建和执行进行控制。<br>1.Executor框架<br>1.1任务的创建<br>在JAVA类库中，任务执行的主要抽象不是Thread，而是Executor。Executor是个简单的接口，但是它提供了一种标准的方法将任务的提交过程与执行构成解耦开，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。<br>Executor是基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。如果要在程序中实现一个生产者-消费者的设计，那么最简单的方式通常就是使用Executor。<br>下面是一个使用Executor来实现的Web服务器<br>class TaskExecutionWebServer{<br>    private static final int NTHREADS=100;<br>    private static final Executor exec=Executors.newFixedThreadPool(NTHREADS);</p>
<pre><code>public static void main(String []args) throws IOException{
    ServerSocket socket=new ServerSocket(80);
    while(true){
        final Socket connection=socket.accept();
        Runnable task=new Runnable() {

            public void run() {
                handleRequest(connection);

            }
        };
        exec.execute(task);
    }
}
</code></pre><p>}<br>通过使用Executor，将请求出处理任务的提交与任务的实际执行解耦开来，并且只需要采用另一种不同的Executor实现，就可以改变服务器的行为。<br>1.2任务生命周期的管理<br>Executor扩展了ExecutorService接口，添加了一些用于生命周期管理的方法。其中shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成。shutdownNow方法将执行粗暴的关闭过程，它将取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。<br>2.Callable和Future<br>Executor框架使用Runable作为基本的任务表示形式，但是Runable是一种有很大局限性的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但他不能返回一个值或者抛出一个受检查的异常。<br>实际上许多任务都是存在延迟的计算，比如执行数据库查询、从网络上获取资源，对于这些任务，Callable是一种更好的抽象：它认为主入口点将返回一个值，并可能抛出一个异常。在Executor中，有一些辅助的方法可以将Runable等其他任务封装成一个Callable。<br>Future表示一个任务的生命周期，并提供相应的方法来判断是否已经完成或者取消，以及获得任务的结果和取消任务等。其中get方法的行为取决于任务的状态。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务取消，那么get将抛出CancellationException。如果get抛出了ExceptionException，那么可以通过getCause来获得被封装的初始异常。<br>可以通过许多种方法创建一个Future来描述任务.ExceptionService中的所有submit方法都将返回一个Future，从而将一个Runable或者Callable提交给Executor，并得到一个Future用来获得任务的执行结果或者取消任务。还可以显示的为某个指定的Runable或者Callable实例一个FutureTask。<br>为了是页面渲染实现更高的并发性，首先将渲染过程分解为两个任务，一个是渲染所有的文本，另一个是下载所有的图像。可以用Callable和Future来表示这些协同任务之间的交互。代码如下：<br>class TaskExecutionWebServer{<br>    private static final int NTHREADS=100;<br>    private static final Executor exec=Executors.newFixedThreadPool(NTHREADS);</p>
<pre><code>public static void main(String []args) throws IOException{
    ServerSocket socket=new ServerSocket(80);
    while(true){
        final Socket connection=socket.accept();
        Runnable task=new Runnable() {

            public void run() {
                handleRequest(connection);

            }
        };
        exec.execute(task);
    }
}
</code></pre><p>}</p>
<p>class FutureRenderer{<br>    private static final ExecutorService exec=…;</p>
<pre><code>void renderPage(CharSequence source){
    final List&lt;ImageInfo&gt; imageInfos=scanForImageInfo(source);
    Callable&lt;List&lt;ImageData&gt;&gt; task=
            new Callable&lt;List&lt;ImageData&gt;&gt;(){

                public List&lt;ImageData&gt; call() throws Exception {
                    List&lt;ImageData&gt; result=new ArrayList&lt;ImageData&gt;();
                    for(ImageInfo imageInfo:imageInfos){
                        result.add(imageInfo.downloadImage());
                    }
                    return result;
                }

    };

    Future&lt;List&lt;ImageData&gt;&gt;future=exec.submit(task);
    renderText(source);

    try{
        List&lt;ImageData&gt;imageData=future.get();
        for(ImageData data:iamgeData)
            renderImage(data);
    }catch(InterruptedException e){
        //重新设置线程的中断状态
        Thread.currentThread().interrupt();
        //由于不需要结果，因此重新取消任务
        future.cancle(true);
    }catch(ExecutionException e){
        throw e.getCause();
    }
}
</code></pre><p>}<br>Futureender中创建了一个Callbale来下载所有的图像，并将其提交到一个ExecutorService。这将返回一个描述任务执行情况的Future。当主任务需要图像是，它将等待Future.get的调用结果。如果幸运的话，当开始请求是所有的图像就已经开始下载了，即使没有，至少图像下载的任务已经提前开始了。<br>3.CompletionService<br>如果想Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout设置为0，从而通过轮询来判断任务是否完成。这种办法虽然可行，但是繁琐。我们可以使用CompletionService来进行处理。<br>CompletionService将Executor和BlockingQuene的功能融合在了一起。可以将Callable任务提交给它进行执行，然后使用类似于队列操作的take和poll方法来获得已经完成的结果，而这些结果会在完成是被封装成Future。<br>针对上面的页面渲染功能，如果使用CompletionService的话可以从两个方面来进行提高：缩短总运行时间以及提高响应性。为每一幅图像的下载都创建一个独立的任务，并在线程池中执行它们，从而将串行的下载过程转化为并行的过程：这将减少下载所有图像的总时间。此外，通过从CompletionService中获取结果以及使每张图片在下载完成后立刻显示出来，能使用户获得一个更加动态和更高响应性的用户界面。代码如下：<br>public void renderPage(CharSequence source){<br>        List<imageinfo> info=scanForImageInfo(source);<br>        CompletionService<imagedata> completionService=<br>                new ExecutorCompletionService<imagedata>(executor) ;</imagedata></imagedata></imageinfo></p>
<pre><code>    for(final ImageInfo imageInfo:info){
        completionService.submit(new Callable&lt;ImageData&gt;() {
            public ImageData call(){
                return imageInfo.downloadImage();
            }
        });

        renderTxt(source);

        try{
            for(int t=0,n=info.size();t&lt;n;t++){
                Future&lt;ImageData&gt; f=completionService.take();
                ImageData imageData=f.get();
                renderImage(iamgeData);
            }
        }catch(InterruptedException e){
            Thread.currentThread().interrupt();
        }catch (ExecutionException e){
            throw launderThrowable(e.getCause());
        }
    }
}
</code></pre><p>}</p>
<p>除了对线程的执行需要进行控制以外，还需要控制任务的取消和关闭。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/22/java并发编程/" data-id="cix0hoe2i0003pkp2zf44bfdi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java并发编程一（资源访问控制）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/22/java并发编程一（资源访问控制）/" class="article-date">
  <time datetime="2016-12-22T14:04:00.000Z" itemprop="datePublished">2016-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/java并发编程一（资源访问控制）/">java并发编程一（资源访问控制）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>并发编程，是指通过多个线程之间的相互配合来实现一定的功能。因此多线程之间的控制（资源请求控制，线程执行控制）是实现并发编程的基础。</p>
<hr>
<h2 id="多线程的资源访问控制"><a href="#多线程的资源访问控制" class="headerlink" title="多线程的资源访问控制"></a>多线程的资源访问控制</h2><p>首先我们先看一下多线程之间的资源访问控制。</p>
<p>程序中的资源被经过一些操作可以得到我们想要的结果，当资源只被一个线程所执行，或者线程的操作不依赖于资源的上下文时，资源的处理结果一般都是可靠的，否则往往会出现意想不到的结果。</p>
<p>我们可以通过以下几种方式对资源的操作进行控制。</p>
<hr>
<h2 id="1-让资源不可变"><a href="#1-让资源不可变" class="headerlink" title="1.让资源不可变"></a>1.让资源不可变</h2><p>当资源是不可变的时候，程序也就无法对它进行操作，自然也不会出现线程安全问题。</p>
<p>对于在访问和更新相关变量时出现的竞争条件问题，可以通过这些将这些变量全部保存在一个不可变对象中来消除问题。</p>
<p>满足以下条件的对象才是不可变的：<br>1）对象创建以后其状态就不能修改<br>2）对于的所有域都是final类型<br>3）对象是安全创建的（在对象的创建期间，this引用没有逸出）</p>
<hr>
<h2 id="2-将资源封闭在线程内"><a href="#2-将资源封闭在线程内" class="headerlink" title="2.将资源封闭在线程内"></a>2.将资源封闭在线程内</h2><p>如果一个资源的创建到消失，都在一个线程内部的话，其他的线程也就无法对它进行操作，这样就保证了线程操作结果的可靠性。这种技术称之为线程封闭。</p>
<p>线程封闭的技术一个常见的应用场景是JDBC的Connection对象，在典型的服务器应用程序中，线程从连接池获得一个Connection对象，然后使用该对象处理请求，使用完后再返还给连接池。由于大多数请求（例如Servlet或者EJB调用）都是又单个线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会将它再分配给其他的线程，因此，这种处理方式保证了Connection的线程安全。</p>
<p>有以下三种方式实现线程封闭。</p>
<hr>
<h2 id="2-1Ad-hoc线程封闭"><a href="#2-1Ad-hoc线程封闭" class="headerlink" title="2.1Ad-hoc线程封闭"></a>2.1Ad-hoc线程封闭</h2><p>Ad-hoc线程封闭式指，维护线程封闭性的职责完全由程序来承担。Ad-hoc线程封闭式非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或者局部变量，能将对象封闭到模板线程上。因此在程序中使用的非常少。</p>
<hr>
<h2 id="2-2栈封闭"><a href="#2-2栈封闭" class="headerlink" title="2.2栈封闭"></a>2.2栈封闭</h2><p>栈封闭式线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，其他线程无法访问这个栈。</p>
<p>需要注意的是，在维持栈封闭时，需要注意被引用的对象不能逸出。因此编码人员在编写代码时，对于不能逸出的对象要特别进行标明，防止后续的维护人员错误的使对象逸出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span></span>&#123;</span><br><span class="line">		List&lt;Animal&gt; animals;</span><br><span class="line">		<span class="keyword">int</span> numPairs=<span class="number">0</span>;</span><br><span class="line">		 Animal candidate=<span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		animals=<span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">		animals.addAll( candidates);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(Animal a:animals)&#123;</span><br><span class="line">			numPairs=numPairs+a.getPairs();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> numPairs;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，无论如何操作animals都不会对其他线程造成影响，每个线程维护自己的变量，但是如果发布了animals的引用，那么就会造成对象的逸出，其他线程对该引用进行操作时，就会造成这个程序的错误。</p>
<hr>
<h2 id="2-3ThreadLocal类"><a href="#2-3ThreadLocal类" class="headerlink" title="2.3ThreadLocal类"></a>2.3ThreadLocal类</h2><p>维护线程封闭性的更规范的方法是使用ThreadLocal，这个类能使线程中某个值与保存值得对象关联起来。ThreadLocal提供了get和set等访问接口或者方法，这些方法为每个使用该变量的线程都有一个独立的副本，因此get总是返回当前执行线程在调用set时设置的最新值。</p>
<p>ThreadLocal对象通常用于防止对可变的单例实例变量或者全局变量进行共享。例如，在单线程应用程序中可能会维护一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都需要传播一个Connection对象。由于JDBC的连接对象不一定是线程安全的。因此，当多线程应用程序在没有协调的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLoacl对象中，每个线程都会拥有属于自己的连接，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder =</span><br><span class="line">			<span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> DriverManager.getConnection(url);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>当某个程序初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。从概念上看，可以将ThreadLocal<t>视为包含了Map<thread,t>对象，其中保存了特定于该线程的值，但ThreadLocal的实现并非如此。这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。<br>当某个频繁执行的操作需要一个临界对象，例如一个缓冲区，而同时有希望避免在每次执行时都重新分配该临界对象，就可以使用这项技术。</thread,t></t></p>
<p>假设需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转移为ThreadLocal对象，可以维护线程安全性。然而，如果将应用程序范围内的缓存转换为线程局部的缓存，就不会有太大的作用。</p>
<p>在实现应用程序框架时大量使用了ThreadLocal。例如，在EJB的调用期间，J2EE容器需要将一个事务上下文与某个执行中的线程关联起来。通过将事务上下文保存在静态的ThreadLocal对象中，就可以很容易实现这个功能：当框架代码需要判断当前运行的是哪一个事务时，只需要从这个ThreadLocal对象中读取事务的上下文。这种机制很方便，因为它避免了在调用每个方法时都传播上下文信息，然而这也将是用该机制的代码与框架耦合在一起。</p>
<p>ThreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p>
<hr>
<h2 id="3-安全发布对象"><a href="#3-安全发布对象" class="headerlink" title="3.安全发布对象"></a>3.安全发布对象</h2><p>前面讲了安全访问对象的一些办法，但是对象安全访问并不能保证对象一定是安全的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  Holder holder;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">		holder=<span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>上述这段代码即使在初始化过程中正确构建了不变性的条件在多线程状态下运行会发生错误，这是由于可见性的问题，其他线程可能看到尚未创建好完整的Holder对象。这样不安全的发布对象将造成，除了发布对象外，其他线程看到的Holder域是一个空引用或者是之前的值，或者，线程看到的Holder引用的值是最新的，但是状态值是失效的，更加严重的是，线程第一次看到的状态值是失效的，第二次读取时得到更新值，这个时候就会发生错误。因此对于对象不仅要安全的引用，还要安全的发布。</p>
<p>如果上述Holder域是不可变的，那么即使没有安全的发布，程序也不会发生错误。对于不可变对象来说，Java内部模式提供了特殊的初始化保证，即使对象没有安全的发布，对象仍然可以安全的访问。</p>
<p>可以通过以下几步构造一个不可变的对象：<br>1）将类声明为final，所以它不能被继承；<br>2）将所有的成员声明为私有的，这样就不允许直接访问这些成员；<br>3）对变量不要提供setter方法；<br>4）将所有可变的成员声明为final，这样只能对它们赋值一次；<br>5）通过构造器初始化所有成员，进行深拷贝（deep copy）；<br>6）在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝；</p>
<p>如果想要安全的发布一个对象，那么对象的引用以及对象的状态必须同时对于其他线程可见。</p>
<p>一个正确构造的对象可以通过以下几种方式进行发布：<br>1.在静态初始化函数中初始化一个对象的引用，最简单的方法就是使用静态的初始化器。<br>2.将对象的引用保存到volatile类型的域或者AtmicReferance对象中。<br>3.将对象的引用保存到某个正确构造对象的final类型域中。<br>4.将对象的引用保存到一个由锁保护的域中。</p>
<p>java容器中有一些特别的容器，可以保证存放在里面的对象可以安全的发布。它们分别是HashTable、synchronizedMap、ConcurrentMap、Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList、synchronizedSet、BlockingQueue以及ConcurrentLinkedQuene。</p>
<p>如果一个对象在发布之后从技术上看是可变的，但是其状态在发布之后不会再改变，那么把这种对象称之为事实不可变对象，对于这种对象，只要能够安全发布即可。通过使用事实不可变对象，即能够简化开发还能够提高程序性能。</p>
<p>如何对象是可变的，那么不仅要在发布的时候使用同步，在访问的时候同样需要同步来保证后续操作的可见性。</p>
<p>因此，对象的发布取决于它的可变性：<br>1.不可变的对象可以通过任意的机制发布。<br>2.事实不可变的对象必须通过安全方式来发布。<br>3.可变对象必须通过安全方式来发布，并且对象的操作必须是线程安全的或者由某个锁保护起来。</p>
<hr>
<h2 id="最后的简单小结"><a href="#最后的简单小结" class="headerlink" title="最后的简单小结"></a>最后的简单小结</h2><p>在并发程序中使用和共享对象时，可以使用一些实用的策略来保证对象的正确性：<br>1.线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在线程中，只能由这个线程修改。<br>2.只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但是任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。<br>3.线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过公有接口来进行访问而不需要进一步的同步。<br>4.保护对象。被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其他线程安全对象中的对象，已经已经发布的并且由某个特定锁保护的对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/22/java并发编程一（资源访问控制）/" data-id="cix0hoe2l0004pkp28e02dspk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java并发编程二（任务执行控制）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/22/java并发编程二（任务执行控制）/" class="article-date">
  <time datetime="2016-12-22T14:04:00.000Z" itemprop="datePublished">2016-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/java并发编程二（任务执行控制）/">java并发编程二（任务执行控制）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一节简单介绍了关于资源访问方面的控制，但是除了对资源的访问控制，也可以对线程的执行进行控制。</p>
<p>大多数的并发应用程序都是围绕“任务执行”来进行构造的，在理想情况下，各个任务之间是相互独立的，任务并不依赖于其他任务的状态、结果和边界效应。越高的独立性越有助于实现并发，因为在足够多的处理资源情况下，这些独立的任务都可以并行的执行。在正常负载的情况下，为每个任务分配一个线程的方法能够提升串行执行的性能。但是实际情况中，这种方法有着很严重的缺陷，尤其是需要创建大量线程时，因为线程生命周期的开销非常高，尤其是在请求量很高，但是处理过程是轻量的情况下，将浪费大量额计算资源。另外如果可运行的线程数量多于可用处理器的数量，那么有些线程将闲置，大量空闲的线程会占用很多内存，给垃圾回收器带来压力。另外一个问题是可创建线程的数量存在一个闲置，这个闲置受到平台操作系统，JVM等环境的影响。因此我们需要使用一定的策略来对线程的创建和执行进行控制。</p>
<p>下面简单介绍一下控制任务执行的几种方法。</p>
<hr>
<h2 id="1-Executor框架"><a href="#1-Executor框架" class="headerlink" title="1.Executor框架"></a>1.Executor框架</h2><hr>
<h2 id="1-1任务的创建"><a href="#1-1任务的创建" class="headerlink" title="1.1任务的创建"></a>1.1任务的创建</h2><p>在JAVA类库中，任务执行的主要抽象不是Thread，而是Executor。Executor是个简单的接口，但是它提供了一种标准的方法将任务的提交过程与执行构成解耦开，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。</p>
<p>Executor是基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。如果要在程序中实现一个生产者-消费者的设计，那么最简单的方式通常就是使用Executor。</p>
<p>下面是一个使用Executor来实现的Web服务器。</p>
<p>```java<br>class TaskExecutionWebServer{<br>    private static final int NTHREADS=100;<br>    private static final Executor exec=Executors.newFixedThreadPool(NTHREADS);</p>
<pre><code>public static void main(String []args) throws IOException{
    ServerSocket socket=new ServerSocket(80);
    while(true){
        final Socket connection=socket.accept();
        Runnable task=new Runnable() {

            public void run() {
                handleRequest(connection);

            }
        };
        exec.execute(task);
    }
}
</code></pre><p>}<br>```java</p>
<p>通过使用Executor，将请求出处理任务的提交与任务的实际执行解耦开来，并且只需要采用另一种不同的Executor实现，就可以改变服务器的行为。</p>
<hr>
<h2 id="1-2任务生命周期的管理"><a href="#1-2任务生命周期的管理" class="headerlink" title="1.2任务生命周期的管理"></a>1.2任务生命周期的管理</h2><p>Executor扩展了ExecutorService接口，添加了一些用于生命周期管理的方法。其中shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成。shutdownNow方法将执行粗暴的关闭过程，它将取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p>
<p>由于ExecutorService由Executor扩展而来，因此ExecutorService可以使用Executor的初始化方法。</p>
<hr>
<h2 id="2-Callable和Future"><a href="#2-Callable和Future" class="headerlink" title="2.Callable和Future"></a>2.Callable和Future</h2><p>Executor框架使用Runable作为基本的任务表示形式，但是Runable是一种有很大局限性的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但他不能返回一个值或者抛出一个受检查的异常。也就是说你不能等待线程的返回值来进行一些操作。</p>
<p>然而实际上许多任务都是存在延迟的计算，比如执行数据库查询、从网络上获取资源，对于这些任务，Callable是一种更好的抽象：它认为主入口点将返回一个值，并可能抛出一个异常。在Executor中，有一些辅助的方法可以将Runable等其他任务封装成一个Callable。</p>
<p>Future表示一个任务的生命周期，并提供相应的方法来判断是否已经完成或者取消，以及获得任务的结果和取消任务等。其中get方法的行为取决于任务的状态。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务取消，那么get将抛出CancellationException。如果get抛出了ExceptionException，那么可以通过getCause来获得被封装的初始异常。</p>
<p>可以通过许多种方法创建一个Future来描述任务。ExceptionService中的所有submit方法都将返回一个Future，从而将一个Runable或者Callable提交给Executor，并得到一个Future用来获得任务的执行结果或者取消任务。还可以显示的为某个指定的Runable或者Callable实例一个FutureTask。</p>
<p>为了是页面渲染实现更高的并发性，首先将渲染过程分解为两个任务，一个是渲染所有的文本，另一个是下载所有的图像。可以用Callable和Future来表示这些协同任务之间的交互。</p>
<p>示例代码如下：<br>```java</p>
<p>class FutureRenderer{<br>    private static final ExecutorService exec=…;</p>
<pre><code>//渲染页面
void renderPage(CharSequence source){
    final List&lt;ImageInfo&gt; imageInfos=scanForImageInfo(source);

    //生成任务
    Callable&lt;List&lt;ImageData&gt;&gt; task=
            new Callable&lt;List&lt;ImageData&gt;&gt;(){

                public List&lt;ImageData&gt; call() throws Exception {
                    List&lt;ImageData&gt; result=new ArrayList&lt;ImageData&gt;();

                    for(ImageInfo imageInfo:imageInfos){
                        result.add(imageInfo.downloadImage());
                    }

                    return result;
                }

    };

    //任务提交
    Future&lt;List&lt;ImageData&gt;&gt;future=exec.submit(task);

    renderText(source);

    try{
        //等待任务执行结果
        List&lt;ImageData&gt;imageData=future.get();

        //渲染图片
        for(ImageData data:iamgeData)
            renderImage(data);

    }catch(InterruptedException e){
        //重新设置线程的中断状态
        Thread.currentThread().interrupt();
        //由于不需要结果，因此重新取消任务
        future.cancle(true);
    }catch(ExecutionException e){
        throw e.getCause();
    }
}
</code></pre><p>}<br>```java</p>
<p>Futureender中创建了一个Callbale来下载所有的图像，并将其提交到一个ExecutorService。这将返回一个描述任务执行情况的Future。当主任务需要图像是，它将等待Future.get的调用结果。如果幸运的话，当开始请求是所有的图像就已经开始下载了，即使没有，至少图像下载的任务已经提前开始了。</p>
<hr>
<h2 id="3-CompletionService"><a href="#3-CompletionService" class="headerlink" title="3.CompletionService"></a>3.CompletionService</h2><p>如果想Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout设置为0，从而通过轮询来判断任务是否完成。这种办法虽然可行，但是繁琐。我们可以使用CompletionService来进行处理。</p>
<p>CompletionService将Executor和BlockingQuene的功能融合在了一起。可以将Callable任务提交给它进行执行，然后使用类似于队列操作的take和poll方法来获得已经完成的结果，而这些结果会在完成是被封装成Future。</p>
<p>针对上面的页面渲染功能，如果使用CompletionService的话可以从两个方面来进行提高：缩短总运行时间以及提高响应性。为每一幅图像的下载都创建一个独立的任务，并在线程池中执行它们，从而将串行的下载过程转化为并行的过程：这将减少下载所有图像的总时间。此外，通过从CompletionService中获取结果以及使每张图片在下载完成后立刻显示出来，能使用户获得一个更加动态和更高响应性的用户界面。</p>
<p>代码如下：<br>```java<br>public void renderPage(CharSequence source){</p>
<pre><code>    List&lt;ImageInfo&gt; info=scanForImageInfo(source);

    //通过executor初始化CompletionService
    CompletionService&lt;ImageData&gt; completionService=
            new ExecutorCompletionService&lt;ImageData&gt;(executor) ;

    for(final ImageInfo imageInfo:info){

        //任务提交
        completionService.submit(new Callable&lt;ImageData&gt;() {

            public ImageData call(){
                return imageInfo.downloadImage();
            }

        });

        renderTxt(source);

        try{
            for(int t=0,n=info.size();t&lt;n;t++){
                //获得任务执行的结果
                Future&lt;ImageData&gt; f=completionService.take();

                ImageData imageData=f.get();
                renderImage(iamgeData);
            }
        }catch(InterruptedException e){
            Thread.currentThread().interrupt();
        }catch (ExecutionException e){
            throw launderThrowable(e.getCause());
        }
    }
}
</code></pre><p>}<br>```java</p>
<p>在初始化CompletionService的时候，我们可以指定不同的executor，也可以指定相同的executor。这与Future是非常相似的。</p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过围绕任务执行来设计应用程序，可以简化开发过程，并有助于实现并发。Executor框架将任务提交与执行策略解耦开来，同时还支持多种不同类型的执行策略。当需要创建线程执行任务是，可以考虑使用Executor。除此之外我们还可以通过Callable和Future来获得对任务更多的控制。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/22/java并发编程二（任务执行控制）/" data-id="cix0hoe3c000dpkp203k9l348" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于类拷贝的分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/06/关于类拷贝的分析/" class="article-date">
  <time datetime="2016-11-06T07:04:00.000Z" itemprop="datePublished">2016-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/06/关于类拷贝的分析/">关于类拷贝工具的分析与比较</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="关于类拷贝："><a href="#关于类拷贝：" class="headerlink" title="关于类拷贝："></a>关于类拷贝：</h2><p>在Java项目尤其是Java Web项目中，由于分层设计的原因，经常出现很多层次的Java Bean，这些Java Bean虽然是不同的类，但是他们的属性有99%是一样的。因此经常需要对不同的类进行属性拷贝，将这些属性名相同的属性进行拷贝。</p>
<hr>
<h2 id="常用的类拷贝工具有："><a href="#常用的类拷贝工具有：" class="headerlink" title="常用的类拷贝工具有："></a>常用的类拷贝工具有：</h2><p>Apache的两个版本：（反射机制）<br>org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)<br>org.apache.commons.beanutils.BeanUtils.copyProperties(Object dest, Object orig)<br>Spring版本：（反射机制）<br>org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties)<br>cglib版本：（使用动态代理，效率高）<br>net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter)</p>
<hr>
<h2 id="各工具的使用注意事项："><a href="#各工具的使用注意事项：" class="headerlink" title="各工具的使用注意事项："></a>各工具的使用注意事项：</h2><p>这里参考了<a href="http://blog.csdn.net/jianhua0902/article/details/8155368" target="_blank" rel="external">http://blog.csdn.net/jianhua0902/article/details/8155368</a> 这篇文章</p>
<p><table class="table" style="word-break: break-all;"><br>    <tr><br>        <th>工具</th><br>        <th>是否支持用户扩展类型转化</th><br>        <th>参数(sourceObject，targetObject）的顺序</th><br>        <th>是否能够对空值属性进行操作</th><br>        <th>是否支持对同名不同类型属性的拷贝</th><br>        <th>当Java Bean出现get和set方法不匹配</th><br>    </tr><br>    <tr><br>        <td>Apache PropertyUtils</td><br>        <td>不支持</td><br>        <td>逆序</td><br>        <td>可以</td><br>        <td>不支持，会抛出异常</td><br>        <td>仍然支持</td><br>    </tr><br>    <tr><br>        <td>Apache BeanUtils</td><br>        <td>支持</td><br>        <td>逆序</td><br>        <td>不可以，会抛出异常</td><br>        <td>支持，能进行简单的转化</td><br>        <td>仍然支持</td><br>    </tr><br>    <tr><br>        <td>Spring BeanUtils</td><br>        <td>支持</td><br>        <td>顺序</td><br>        <td>可以</td><br>        <td>不支持，会抛出异常</td><br>        <td>仍然支持</td><br>    </tr><br>    <tr><br>        <td>Cglib BeanCopier</td><br>        <td>支持，但是难用</td><br>        <td>顺序</td><br>        <td>可以</td><br>        <td>支持，该属性不拷贝    </td><br>        <td>创建拷贝的时候出错</td><br>    </tr></table></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="各工具的性能比较："><a href="#各工具的性能比较：" class="headerlink" title="各工具的性能比较："></a>各工具的性能比较：</h2><p>在这里，创建了两个类型不同，但是属性名完全相同的两个Java Bean。<br>（测试案例来自于<a href="http://www.cnblogs.com/kaka/archive/2013/03/06/2945514.html）" target="_blank" rel="external">http://www.cnblogs.com/kaka/archive/2013/03/06/2945514.html）</a><br>对他们进行拷贝，在拷贝次数较少和拷贝次数较多的情况下，得出如下的比较结果，每次计时以毫秒为单位。</p>
<table>
<thead>
<tr>
<th style="text-align:center">10次测拷贝</th>
<th style="text-align:center">第一次</th>
<th style="text-align:center">第二次</th>
<th style="text-align:center">第三次</th>
<th style="text-align:center">平均值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Apache BeanUtils</td>
<td style="text-align:center">95</td>
<td style="text-align:center">101</td>
<td style="text-align:center">102</td>
<td style="text-align:center">99.33</td>
</tr>
<tr>
<td style="text-align:center">Apache PropertyUtils</td>
<td style="text-align:center">10</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">Spring BeanUtils</td>
<td style="text-align:center">57</td>
<td style="text-align:center">66</td>
<td style="text-align:center">63</td>
<td style="text-align:center">186</td>
</tr>
<tr>
<td style="text-align:center">Cglib BeanCopier</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0.33</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">10000次测拷贝</th>
<th style="text-align:center">第一次</th>
<th style="text-align:center">第二次</th>
<th style="text-align:center">第三次</th>
<th style="text-align:center">平均值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Apache BeanUtils</td>
<td style="text-align:center">309</td>
<td style="text-align:center">361</td>
<td style="text-align:center">292</td>
<td style="text-align:center">320</td>
</tr>
<tr>
<td style="text-align:center">Apache PropertyUtils</td>
<td style="text-align:center">115</td>
<td style="text-align:center">108</td>
<td style="text-align:center">120</td>
<td style="text-align:center">114</td>
</tr>
<tr>
<td style="text-align:center">Spring BeanUtils</td>
<td style="text-align:center">64</td>
<td style="text-align:center">75</td>
<td style="text-align:center">68</td>
<td style="text-align:center">69</td>
</tr>
<tr>
<td style="text-align:center">Cglib BeanCopier</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>上述实验是在我的个人笔记本上进行的，配置为MacBook Air，处理器为1.6 GHz Intel Core i5，内存为8 GB 1600 MHz DDR3。<br>可以看到，不管在少量拷贝下还是在大量拷贝下，Cglib的性能最好，这也是因为Cglib进行了缓存的原因。在少量数据下Apache PropertyUtils的性能还是很不错的，但是在大量数据下就比Spring BeanUtils差了，而Apache BeanUtils无论是在少量拷贝还是在大量拷贝的情况下性能表现都比较差。</p>
<hr>
<h2 id="各工具的实现对比"><a href="#各工具的实现对比" class="headerlink" title="各工具的实现对比"></a>各工具的实现对比</h2><p>前面已经简单的讲到apache的工具以及spring的工具都是有反射机制实现类的拷贝，而Cglib则是使用动态代理的机制，先创建一个代理类放入jvm中，这个操作比较耗时，因此适合设计成单例模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/06/关于类拷贝的分析/" data-id="cix0hoe2p0006pkp27bl58ik1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http与https的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/04/http与https的区别/" class="article-date">
  <time datetime="2016-09-04T07:04:00.000Z" itemprop="datePublished">2016-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/04/http与https的区别/">http与https的区别（转载）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="首先谈谈什么是HTTPS："><a href="#首先谈谈什么是HTTPS：" class="headerlink" title="首先谈谈什么是HTTPS："></a>首先谈谈什么是HTTPS：</h2><p>HTTPS(Secure Hypertext Transfer Protocol)安全超文本传输协议 它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。 它是由Netscape开发并内置于其浏览器中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果。</p>
<p>HTTPS实际上应用了Netscape的安 全全套接字层(SSL)作为HTTP应用层的子层。(HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。)SSL使 用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X。509数字认证，如果需要的话用户可以确认发送者是谁。</p>
<hr>
<h2 id="HTTPS和HTTP的区别："><a href="#HTTPS和HTTP的区别：" class="headerlink" title="HTTPS和HTTP的区别："></a>HTTPS和HTTP的区别：</h2><p>https协议需要到ca申请证书，一般免费证书很少，需要交费。</p>
<p>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http和https使用的是完全不同的连接方式用的端口也不一样：前者是80，后者是443。</p>
<p>http的连接很简单，是无状态的 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全 HTTPS解决的问题：</p>
<p>1、信任主机的问题。 采用https 的server 必须从CA 申请一个用于证明服务器用途类型的证书。</p>
<p>改证书只有用于对应的server 的时候，客户度才信任次主机。所以目前所有的银行系统网站，关键部分应用都是https 的。 客户通过信任该证书，从而信任了该主机。其实这样做效率很低，但是银行更侧重安全。 这一点对我们没有任何意义，我们的server，采用的证书不管自己issue 还是从公众的地方issue， 客户端都是自己人，所以我们也就肯定信任该server。</p>
<p>2、通讯过程中的数据的泄密和被窜改。</p>
<p>1）一般意义上的https， 就是 server 有一个证书。</p>
<p>a) 主要目的是保证server 就是他声称的server。这个跟第一点一样。</p>
<p>b) 服务端和客户端之间的所有通讯，都是加密的。</p>
<p>i、具体讲，是客户端产生一个对称的密钥，通过server 的证书来交换密钥。 一般意义上的握手过程。</p>
<p>ii、加下来所有的信息往来就都是加密的。 第三方即使截获，也没有任何意义。因为他没有密钥。 当然窜改也就没有什么意义了。</p>
<p>2）少许对客户端有要求的情况下，会要求客户端也必须有一个证书。</p>
<p>a) 这里客户端证书，其实就类似表示个人信息的时候，除了用户名/密码， 还有一个CA 认证过的身份。 应为个人证书一般来说上别人无法模拟的，所有这样能够更深的确认自己的身份。</p>
<p>b) 目前少数个人银行的专业版是这种做法，具体证书可能是拿U盘作为一个备份的载体。像我用的交通银行的网上银行就是采取的这种方式。 HTTPS 一定是繁琐的。</p>
<p>a) 本来简单的http协议，一个get一个response。由于https 要还密钥和确认加密算法的需要。单握手就需要6/7 个往返。</p>
<p>i、任何应用中，过多的round trip 肯定影响性能。</p>
<p>b) 接下来才是具体的http协议，每一次响应或者请求， 都要求客户端和服务端对会话的内容做加密/解密。</p>
<p>i、尽管对称加密/解密效率比较高，可是仍然要消耗过多的CPU，为此有专门的SSL 芯片。 如果CPU 信能比较低的话，肯定会降低性能，从而不能serve 更多的请求。</p>
<hr>
<h2 id="附：SSL的简介："><a href="#附：SSL的简介：" class="headerlink" title="附：SSL的简介："></a>附：SSL的简介：</h2><p>SSL是Netscape公司所提出的安全保密协议，在浏览器(如Internet Explorer、Netscape Navigator)和Web服务器(如Netscape的Netscape Enterprise Server、ColdFusion Server等等)之间构造安全通道来进行数据传输，SSL运行在TCP/IP层之上、应用层之下，为应用程序提供加密数据通道，它采用了RC4、MD5 以及RSA等加密算法，使用40 位的密钥，适用于商业信息的加密。</p>
<p>同时，Netscape公司相应开发了HTTPS协议并内置于其浏览器中，HTTPS实际上就是SSL over HTTP，它使用默认端口443，而不是像HTTP那样使用端口80来和TCP/IP进行通信。HTTPS协议使用SSL在发送方把原始数据进行加密，然 后在接受方进行解密，加密和解密需要发送方和接受方通过交换共知的密钥来实现，因此，所传送的数据不容易被网络黑客截获和解密。</p>
<p>然而，加密和解密过程需要耗费系统大量的开销，严重降低机器的性能，相关测试数据表明使用HTTPS协议传输数据的工作效率只有使用HTTP协议传输的十 分之一。</p>
<p>假如为了安全保密，将一个网站所有的Web应用都启用SSL技术来加密，并使用HTTPS协议进行传输，那么该网站的性能和效率将会大大降低，而且没有这个必要，因为一般来说并不是所有数据都要求那么高的安全保密级别，所以，我们只需对那些涉及机密数据的交互处理使用HTTPS协议，这样就做到鱼与熊掌兼得。总之不需要用https 的地方，就尽量不要用。</p>
<p>＝＝＝＝＝＝＝原文网址：<a href="http://www.chinaz.com/web/2015/0707/420248.shtml＝＝＝＝＝＝" target="_blank" rel="external">http://www.chinaz.com/web/2015/0707/420248.shtml＝＝＝＝＝＝</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/04/http与https的区别/" data-id="cix0hoe210000pkp2721i69xo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-IO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/java-IO/" class="article-date">
  <time datetime="2016-03-15T10:47:29.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/java-IO/">java IO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数据在两台设备之间的传输即是流。java中各种io操作都是流的实现。</p>
<hr>
<h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><p>根据处理数据类型的不同分为：字符流和字节流</p>
<p>根据数据流向不同分为：输入流和输出流</p>
<hr>
<h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>字符流的由来：<br>因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：</p>
<p>（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p>
<p>（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p>
<p>（3）字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；而字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件，我们将在下面验证这一点。</p>
<p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p>
<hr>
<h2 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h2><p>对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。</p>
<hr>
<h2 id="Java-IO流对象"><a href="#Java-IO流对象" class="headerlink" title="Java IO流对象"></a>Java IO流对象</h2><hr>
<h2 id="1-输入字节流InputStream"><a href="#1-输入字节流InputStream" class="headerlink" title="1. 输入字节流InputStream"></a>1. 输入字节流InputStream</h2><p><img src="http://www.mapengju.com/wp-content/uploads/2015/08/20140328140234031.png" alt="image"><br>InputStream 是所有的输入字节流的父类，它是一个抽象类。</p>
<p>ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、String、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据。</p>
<p>ObjectInputStream 和所有FilterInputStream的子类都是装饰流（装饰器模式的主角）。意思是FileInputStream类可以通过一个String路径名创建一个对象，FileInputStream(String name)。而DataInputStream必须装饰一个类才能返回一个对象，DataInputStream(InputStream in)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 字节流</span><br><span class="line">* 读文件内容</span><br><span class="line">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileInputByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len=in.read(b);</span><br><span class="line">in.close();</span><br><span class="line">System.out.println(<span class="string">"读入长度为："</span>+len);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ByteArrayInputStream、StringBufferInputStream的用法类似，实际上它们的用处很有限，我们大多数不会从byte数组和String来获取输入。</p>
<p>我们在使用fileInputStream的时候应该知道，中文是无法正常显示的，如果文件中有中文，那么这种方式并不使用。</p>
<hr>
<h2 id="2-输入字节流OutputStream"><a href="#2-输入字节流OutputStream" class="headerlink" title="2. 输入字节流OutputStream"></a>2. 输入字节流OutputStream</h2><p><img src="http://www.mapengju.com/wp-content/uploads/2015/08/20140328141248890.png" alt="image"><br>OutputStream 是所有的输出字节流的父类，它是一个抽象类。</p>
<p>ByteArrayOutputStream、FileOutputStream是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据，</p>
<p>ObjectOutputStream 和所有FilterOutputStream的子类都是装饰流。具体例子跟InputStream是对应的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayOutByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">OutputStream out =<span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">String str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b=str.getBytes();</span><br><span class="line">out.write(b);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当设置FileOutputStream(f,true)的时候可以在文件末尾追加输出。</p>
<hr>
<h2 id="3-管道流：进程通信"><a href="#3-管道流：进程通信" class="headerlink" title="3. 管道流：进程通信"></a>3. 管道流：进程通信</h2><p>使用管道可以实现进程间的通信：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 消息发送类</span><br><span class="line">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> PipedOutputStream out=<span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">out=<span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getOut</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">String message=<span class="string">"hello , Rollen"</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"发送的消息是"</span>+message);</span><br><span class="line">out.write(message.getBytes());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">try</span>&#123;</span><br><span class="line">out.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 接受消息类</span><br><span class="line">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> PipedInputStream input=<span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Recive</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.input=<span class="keyword">new</span> PipedInputStream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PipedInputStream <span class="title">getInput</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.input;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">len=<span class="keyword">this</span>.input.read(b);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">try</span>&#123;</span><br><span class="line">input.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"接受的内容为 "</span>+(<span class="keyword">new</span> String(b,<span class="number">0</span>,len)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 测试类</span><br><span class="line">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pip</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Send send=<span class="keyword">new</span> Send();</span><br><span class="line">Recive recive=<span class="keyword">new</span> Recive();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//管道连接</span></span><br><span class="line">send.getOut().connect(recive.getInput());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(send).start();</span><br><span class="line"><span class="keyword">new</span> Thread(recive).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="4-字符输入流Reader"><a href="#4-字符输入流Reader" class="headerlink" title="4.字符输入流Reader"></a>4.字符输入流Reader</h2><p><img src="http://www.mapengju.com/wp-content/uploads/2015/08/20140328143211218.png" alt="image"><br>Reader 是所有的输入字符流的父类，它是一个抽象类。</p>
<p>CharReader、StringReader是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。</p>
<p>BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。</p>
<p>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。</p>
<p>InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</p>
<p>下面是实例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readerString</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileName));</span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(in,<span class="string">"gb2312"</span>);</span><br><span class="line"><span class="keyword">int</span> tempchar;</span><br><span class="line"><span class="keyword">while</span> ((tempchar = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 对于windows下，\r\n这两个字符在一起时，表示一个换行。</span></span><br><span class="line"><span class="comment">// 但如果这两个字符分开显示时，会换两次行。</span></span><br><span class="line"><span class="comment">// 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="keyword">char</span>) tempchar) != <span class="string">'\r'</span>) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>) tempchar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从字节到字符，这样就可以解决中文乱码问题了，但是有一点需要注意，需要指定读取文件的编码格式，这样才能正常转换。</p>
<hr>
<h2 id="5-字符输出流Writer"><a href="#5-字符输出流Writer" class="headerlink" title="5.字符输出流Writer"></a>5.字符输出流Writer</h2><p><img src="http://www.mapengju.com/wp-content/uploads/2015/08/20140328143231781.png" alt="image"><br>Writer 是所有的输出字符流的父类，它是一个抽象类。</p>
<p>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。</p>
<p>PipedWriter 是向与其它线程共用的管道中写入数据，</p>
<p>BufferedWriter 是一个装饰器为Writer 提供缓冲功能。</p>
<p>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。</p>
<p>OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileWriterTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">Writer out =<span class="keyword">new</span> FileWriter(f);</span><br><span class="line">String str=<span class="string">"hello"</span>;</span><br><span class="line">out.write(str);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当设置new FileWriter(f,true)的时候可以往文件末尾进行追加。</p>
<hr>
<h2 id="6-字符流与字节流转换"><a href="#6-字符流与字节流转换" class="headerlink" title="6.字符流与字节流转换"></a>6.字符流与字节流转换</h2><hr>
<h2 id="转换流的特点："><a href="#转换流的特点：" class="headerlink" title="转换流的特点："></a>转换流的特点：</h2><p>（1）其是字符流和字节流之间的桥梁</p>
<p>（2）可对读取到的字节数据经过指定编码转换成字符</p>
<p>（3）可对读取到的字符数据经过指定编码转换成字节</p>
<hr>
<h2 id="何时使用转换流？"><a href="#何时使用转换流？" class="headerlink" title="何时使用转换流？"></a>何时使用转换流？</h2><p>当字节和字符之间有转换动作时；</p>
<p>流操作的数据需要编码或解码时。</p>
<hr>
<h2 id="具体的对象体现："><a href="#具体的对象体现：" class="headerlink" title="具体的对象体现："></a>具体的对象体现：</h2><p>InputStreamReader:字节到字符的桥梁</p>
<p>OutputStreamWriter:字符到字节的桥梁</p>
<p>这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。</p>
<hr>
<h2 id="字节流和字符流转换实例："><a href="#字节流和字符流转换实例：" class="headerlink" title="字节流和字符流转换实例："></a>字节流和字符流转换实例：</h2><p>将字节输出流转化为字符输出流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将字节输出流转化为字符输出流</span><br><span class="line">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">byteTocharInput</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileName= <span class="string">"d:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File file=<span class="keyword">new</span> File(fileName);</span><br><span class="line">Writer out=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">out.write(<span class="string">"hello"</span>);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将字节输入流转换为字符输入流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">byteTocharOut</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileName= <span class="string">"d:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File file=<span class="keyword">new</span> File(fileName);</span><br><span class="line">Reader read=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line"><span class="keyword">char</span>[] b=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> len=read.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));</span><br><span class="line">read.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面整理了一份io的工具类，作为一层封装，便于使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoUtils</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 字节流</span><br><span class="line">* 读文件内容</span><br><span class="line">* */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileInputByte</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len=in.read(b);</span><br><span class="line">in.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 根据编码类型通过字符读取文件</span><br><span class="line">* <span class="doctag">@param</span> fileName</span><br><span class="line">* <span class="doctag">@param</span> encoding 编码类型</span><br><span class="line">* <span class="doctag">@return</span></span><br><span class="line">* <span class="doctag">@throws</span> IOException</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileInputString</span><span class="params">(String fileName,String encoding)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileName));</span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(in,encoding);</span><br><span class="line"><span class="keyword">int</span> tempchar;</span><br><span class="line">StringBuffer bf=<span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((tempchar = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 对于windows下，\r\n这两个字符在一起时，表示一个换行。</span></span><br><span class="line"><span class="comment">// 但如果这两个字符分开显示时，会换两次行。</span></span><br><span class="line"><span class="comment">// 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="keyword">char</span>) tempchar) != <span class="string">'\r'</span>) &#123;</span><br><span class="line">bf.append((<span class="keyword">char</span>) tempchar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line"><span class="keyword">return</span> bf.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 以行为单位读取文件，常用于读面向行的格式化文件</span><br><span class="line">* <span class="doctag">@param</span> fileName</span><br><span class="line">* <span class="doctag">@param</span> encoding</span><br><span class="line">* <span class="doctag">@return</span></span><br><span class="line">* <span class="doctag">@throws</span> IOException</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileInputLine</span><span class="params">(String fileName,String encoding)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileName));</span><br><span class="line">Reader _reader = <span class="keyword">new</span> InputStreamReader(in,encoding);</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(_reader);</span><br><span class="line">String tempString = <span class="keyword">null</span>;</span><br><span class="line">StringBuffer bf=<span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 一次读入一行，直到读入null为文件结束</span></span><br><span class="line"><span class="keyword">while</span> ((tempString = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">bf.append(tempString);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line"><span class="keyword">return</span> bf.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 递归删除文件夹下面所有文件</span><br><span class="line">* <span class="doctag">@param</span> file</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(File file)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(file.isFile() || file.list().length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">file.delete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">File[] files = file.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File f : files)</span><br><span class="line">&#123;</span><br><span class="line">deleteAll(f);<span class="comment">//递归删除每一个文件</span></span><br><span class="line">f.delete();<span class="comment">//删除该文件夹</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/15/java-IO/" data-id="cix0hoe2a0001pkp294zzvkug" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 10px;">JAVA</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/22/java并发编程/">java并发编程一（资源访问控制）</a>
          </li>
        
          <li>
            <a href="/2016/12/22/java并发编程一（资源访问控制）/">java并发编程一（资源访问控制）</a>
          </li>
        
          <li>
            <a href="/2016/12/22/java并发编程二（任务执行控制）/">java并发编程二（任务执行控制）</a>
          </li>
        
          <li>
            <a href="/2016/11/06/关于类拷贝的分析/">关于类拷贝工具的分析与比较</a>
          </li>
        
          <li>
            <a href="/2016/09/04/http与https的区别/">http与https的区别（转载）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Peder<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>