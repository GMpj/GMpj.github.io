<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>GMpj</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="GMpj">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="GMpj">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GMpj">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="GMpj" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">GMpj</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-关于类拷贝的分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/06/关于类拷贝的分析/" class="article-date">
  <time datetime="2016-11-06T07:04:00.000Z" itemprop="datePublished">2016-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/06/关于类拷贝的分析/">关于类拷贝工具的分析与比较</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="关于类拷贝："><a href="#关于类拷贝：" class="headerlink" title="关于类拷贝："></a>关于类拷贝：</h2><p>在Java项目尤其是Java Web项目中，由于分层设计的原因，经常出现很多层次的Java Bean，这些Java Bean虽然是不同的类，但是他们的属性有99%是一样的。因此经常需要对不同的类进行属性拷贝，将这些属性名相同的属性进行拷贝。</p>
<hr>
<h2 id="常用的类拷贝工具有："><a href="#常用的类拷贝工具有：" class="headerlink" title="常用的类拷贝工具有："></a>常用的类拷贝工具有：</h2><p>Apache的两个版本：（反射机制）<br>org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)<br>org.apache.commons.beanutils.BeanUtils.copyProperties(Object dest, Object orig)<br>Spring版本：（反射机制）<br>org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties)<br>cglib版本：（使用动态代理，效率高）<br>net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter)</p>
<hr>
<h2 id="各工具的使用注意事项："><a href="#各工具的使用注意事项：" class="headerlink" title="各工具的使用注意事项："></a>各工具的使用注意事项：</h2><p>|工具                    |是否支持用户扩展类型转化|参数(sourceObject，targetObject）的顺序|<br>是否能够对空值属性进行操作|是否支持对同名不同类型属性的拷贝|当Java Bean出现get和set方法不匹配|<br>|:———————:|:—————–:|:———————————-:|<br>:———————-:|:——————–:|:—————————-:|<br>|Apache PropertyUtils    |不支持                |逆序                                 |<br>可以                     |不支持，会抛出异常        |仍然支持                              |<br>|Apache BeanUtils        |支持                |逆序                                 |<br>不可以，会抛出异常            |支持，能进行简单的转化    |仍然支持                              |<br>|Spring BeanUtils        |支持                |顺序                                 |<br>可以                        |不支持                |仍然支持                              |<br>|Cglib BeanCopier        |支持，但是难用        |顺序                                 |<br>可以                        |支持，该属性不拷贝        |创建拷贝的时候出错                      |</p>
<hr>
<h2 id="各工具的性能比较："><a href="#各工具的性能比较：" class="headerlink" title="各工具的性能比较："></a>各工具的性能比较：</h2><p>在这里，创建了两个类型不同，但是属性名完全相同的两个Java Bean,对他们进行拷贝，在拷贝次数较少和拷贝次数较多的情况下，得出如下的比较结果，每次计时以毫秒为单位。<br>|10次测拷贝                |第一次    |第二次    |第三次    |平均值    |<br>|:———————:|:—–:|:—–:|:—–:|:—–:|<br>|Apache BeanUtils        |95        |101    |102     |99.33    |<br>|Apache PropertyUtils    |10        |6        |8         |8        |<br>|Spring BeanUtils        |57        |66        |63      |186    |<br>|Cglib BeanCopier        |0        |0        |1         |0.33    |</p>
<table>
<thead>
<tr>
<th style="text-align:center">10000次测拷贝</th>
<th style="text-align:center">第一次</th>
<th style="text-align:center">第二次</th>
<th style="text-align:center">第三次</th>
<th style="text-align:center">平均值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Apache BeanUtils</td>
<td style="text-align:center">309</td>
<td style="text-align:center">361</td>
<td style="text-align:center">292</td>
<td style="text-align:center">320</td>
</tr>
<tr>
<td style="text-align:center">Apache PropertyUtils</td>
<td style="text-align:center">115</td>
<td style="text-align:center">108</td>
<td style="text-align:center">120</td>
<td style="text-align:center">114</td>
</tr>
<tr>
<td style="text-align:center">Spring BeanUtils</td>
<td style="text-align:center">64</td>
<td style="text-align:center">75</td>
<td style="text-align:center">68</td>
<td style="text-align:center">69</td>
</tr>
<tr>
<td style="text-align:center">Cglib BeanCopier</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>上述实验是在我的个人笔记本上进行的，配置为MacBook Air，处理器为1.6 GHz Intel Core i5，内存为8 GB 1600 MHz DDR3。<br>可以看到，不管在少量拷贝下还是在大量拷贝下，Cglib的性能最好，这也是因为Cglib进行了缓存的原因。在少量数据下Apache PropertyUtils的性能还是很不错的，但是在大量数据下就比Spring BeanUtils差了，而Apache BeanUtils无论是在少量拷贝还是在大量拷贝的情况下性能表现都比较差。</p>
<hr>
<h2 id="各工具的实现对比"><a href="#各工具的实现对比" class="headerlink" title="各工具的实现对比"></a>各工具的实现对比</h2><p>前面已经简单的讲到apache的工具以及spring的工具都是有反射机制实现类的拷贝，而Cglib则是使用动态代理的机制，先创建一个代理类放入jvm中，这个操作比较耗时，因此适合设计成单例模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/06/关于类拷贝的分析/" data-id="civ6q95r000017ruwn6qtxvoa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http与https的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/04/http与https的区别/" class="article-date">
  <time datetime="2016-09-04T07:04:00.000Z" itemprop="datePublished">2016-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/04/http与https的区别/">http与https的区别（转载）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="首先谈谈什么是HTTPS："><a href="#首先谈谈什么是HTTPS：" class="headerlink" title="首先谈谈什么是HTTPS："></a>首先谈谈什么是HTTPS：</h2><p>HTTPS(Secure Hypertext Transfer Protocol)安全超文本传输协议 它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。 它是由Netscape开发并内置于其浏览器中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果。</p>
<p>HTTPS实际上应用了Netscape的安 全全套接字层(SSL)作为HTTP应用层的子层。(HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。)SSL使 用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X。509数字认证，如果需要的话用户可以确认发送者是谁。</p>
<hr>
<h2 id="HTTPS和HTTP的区别："><a href="#HTTPS和HTTP的区别：" class="headerlink" title="HTTPS和HTTP的区别："></a>HTTPS和HTTP的区别：</h2><p>https协议需要到ca申请证书，一般免费证书很少，需要交费。</p>
<p>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http和https使用的是完全不同的连接方式用的端口也不一样：前者是80，后者是443。</p>
<p>http的连接很简单，是无状态的 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全 HTTPS解决的问题：</p>
<p>1、信任主机的问题。 采用https 的server 必须从CA 申请一个用于证明服务器用途类型的证书。</p>
<p>改证书只有用于对应的server 的时候，客户度才信任次主机。所以目前所有的银行系统网站，关键部分应用都是https 的。 客户通过信任该证书，从而信任了该主机。其实这样做效率很低，但是银行更侧重安全。 这一点对我们没有任何意义，我们的server，采用的证书不管自己issue 还是从公众的地方issue， 客户端都是自己人，所以我们也就肯定信任该server。</p>
<p>2、通讯过程中的数据的泄密和被窜改。</p>
<p>1）一般意义上的https， 就是 server 有一个证书。</p>
<p>a) 主要目的是保证server 就是他声称的server。这个跟第一点一样。</p>
<p>b) 服务端和客户端之间的所有通讯，都是加密的。</p>
<p>i、具体讲，是客户端产生一个对称的密钥，通过server 的证书来交换密钥。 一般意义上的握手过程。</p>
<p>ii、加下来所有的信息往来就都是加密的。 第三方即使截获，也没有任何意义。因为他没有密钥。 当然窜改也就没有什么意义了。</p>
<p>2）少许对客户端有要求的情况下，会要求客户端也必须有一个证书。</p>
<p>a) 这里客户端证书，其实就类似表示个人信息的时候，除了用户名/密码， 还有一个CA 认证过的身份。 应为个人证书一般来说上别人无法模拟的，所有这样能够更深的确认自己的身份。</p>
<p>b) 目前少数个人银行的专业版是这种做法，具体证书可能是拿U盘作为一个备份的载体。像我用的交通银行的网上银行就是采取的这种方式。 HTTPS 一定是繁琐的。</p>
<p>a) 本来简单的http协议，一个get一个response。由于https 要还密钥和确认加密算法的需要。单握手就需要6/7 个往返。</p>
<p>i、任何应用中，过多的round trip 肯定影响性能。</p>
<p>b) 接下来才是具体的http协议，每一次响应或者请求， 都要求客户端和服务端对会话的内容做加密/解密。</p>
<p>i、尽管对称加密/解密效率比较高，可是仍然要消耗过多的CPU，为此有专门的SSL 芯片。 如果CPU 信能比较低的话，肯定会降低性能，从而不能serve 更多的请求。</p>
<hr>
<h2 id="附：SSL的简介："><a href="#附：SSL的简介：" class="headerlink" title="附：SSL的简介："></a>附：SSL的简介：</h2><p>SSL是Netscape公司所提出的安全保密协议，在浏览器(如Internet Explorer、Netscape Navigator)和Web服务器(如Netscape的Netscape Enterprise Server、ColdFusion Server等等)之间构造安全通道来进行数据传输，SSL运行在TCP/IP层之上、应用层之下，为应用程序提供加密数据通道，它采用了RC4、MD5 以及RSA等加密算法，使用40 位的密钥，适用于商业信息的加密。</p>
<p>同时，Netscape公司相应开发了HTTPS协议并内置于其浏览器中，HTTPS实际上就是SSL over HTTP，它使用默认端口443，而不是像HTTP那样使用端口80来和TCP/IP进行通信。HTTPS协议使用SSL在发送方把原始数据进行加密，然 后在接受方进行解密，加密和解密需要发送方和接受方通过交换共知的密钥来实现，因此，所传送的数据不容易被网络黑客截获和解密。</p>
<p>然而，加密和解密过程需要耗费系统大量的开销，严重降低机器的性能，相关测试数据表明使用HTTPS协议传输数据的工作效率只有使用HTTP协议传输的十 分之一。</p>
<p>假如为了安全保密，将一个网站所有的Web应用都启用SSL技术来加密，并使用HTTPS协议进行传输，那么该网站的性能和效率将会大大降低，而且没有这个必要，因为一般来说并不是所有数据都要求那么高的安全保密级别，所以，我们只需对那些涉及机密数据的交互处理使用HTTPS协议，这样就做到鱼与熊掌兼得。总之不需要用https 的地方，就尽量不要用。</p>
<p>＝＝＝＝＝＝＝原文网址：<a href="http://www.chinaz.com/web/2015/0707/420248.shtml＝＝＝＝＝＝" target="_blank" rel="external">http://www.chinaz.com/web/2015/0707/420248.shtml＝＝＝＝＝＝</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/04/http与https的区别/" data-id="civ6q95r600037ruwg7229t7g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-IO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/java-IO/" class="article-date">
  <time datetime="2016-03-15T10:47:29.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/java-IO/">java IO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数据在两台设备之间的传输即是流。java中各种io操作都是流的实现。</p>
<hr>
<h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><p>根据处理数据类型的不同分为：字符流和字节流</p>
<p>根据数据流向不同分为：输入流和输出流</p>
<hr>
<h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>字符流的由来：<br>因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：</p>
<p>（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p>
<p>（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p>
<p>（3）字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；而字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件，我们将在下面验证这一点。</p>
<p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p>
<hr>
<h2 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h2><p>对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。</p>
<hr>
<h2 id="Java-IO流对象"><a href="#Java-IO流对象" class="headerlink" title="Java IO流对象"></a>Java IO流对象</h2><hr>
<h2 id="1-输入字节流InputStream"><a href="#1-输入字节流InputStream" class="headerlink" title="1. 输入字节流InputStream"></a>1. 输入字节流InputStream</h2><p><img src="http://www.mapengju.com/wp-content/uploads/2015/08/20140328140234031.png" alt="image"><br>InputStream 是所有的输入字节流的父类，它是一个抽象类。</p>
<p>ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、String、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据。</p>
<p>ObjectInputStream 和所有FilterInputStream的子类都是装饰流（装饰器模式的主角）。意思是FileInputStream类可以通过一个String路径名创建一个对象，FileInputStream(String name)。而DataInputStream必须装饰一个类才能返回一个对象，DataInputStream(InputStream in)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 字节流</span><br><span class="line">* 读文件内容</span><br><span class="line">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileInputByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len=in.read(b);</span><br><span class="line">in.close();</span><br><span class="line">System.out.println(<span class="string">"读入长度为："</span>+len);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ByteArrayInputStream、StringBufferInputStream的用法类似，实际上它们的用处很有限，我们大多数不会从byte数组和String来获取输入。</p>
<p>我们在使用fileInputStream的时候应该知道，中文是无法正常显示的，如果文件中有中文，那么这种方式并不使用。</p>
<hr>
<h2 id="2-输入字节流OutputStream"><a href="#2-输入字节流OutputStream" class="headerlink" title="2. 输入字节流OutputStream"></a>2. 输入字节流OutputStream</h2><p><img src="http://www.mapengju.com/wp-content/uploads/2015/08/20140328141248890.png" alt="image"><br>OutputStream 是所有的输出字节流的父类，它是一个抽象类。</p>
<p>ByteArrayOutputStream、FileOutputStream是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据，</p>
<p>ObjectOutputStream 和所有FilterOutputStream的子类都是装饰流。具体例子跟InputStream是对应的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayOutByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">OutputStream out =<span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">String str=<span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b=str.getBytes();</span><br><span class="line">out.write(b);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当设置FileOutputStream(f,true)的时候可以在文件末尾追加输出。</p>
<hr>
<h2 id="3-管道流：进程通信"><a href="#3-管道流：进程通信" class="headerlink" title="3. 管道流：进程通信"></a>3. 管道流：进程通信</h2><p>使用管道可以实现进程间的通信：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 消息发送类</span><br><span class="line">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> PipedOutputStream out=<span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">out=<span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getOut</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">String message=<span class="string">"hello , Rollen"</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"发送的消息是"</span>+message);</span><br><span class="line">out.write(message.getBytes());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">try</span>&#123;</span><br><span class="line">out.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 接受消息类</span><br><span class="line">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> PipedInputStream input=<span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Recive</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.input=<span class="keyword">new</span> PipedInputStream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PipedInputStream <span class="title">getInput</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.input;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">len=<span class="keyword">this</span>.input.read(b);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">try</span>&#123;</span><br><span class="line">input.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"接受的内容为 "</span>+(<span class="keyword">new</span> String(b,<span class="number">0</span>,len)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 测试类</span><br><span class="line">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pip</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Send send=<span class="keyword">new</span> Send();</span><br><span class="line">Recive recive=<span class="keyword">new</span> Recive();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//管道连接</span></span><br><span class="line">send.getOut().connect(recive.getInput());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(send).start();</span><br><span class="line"><span class="keyword">new</span> Thread(recive).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="4-字符输入流Reader"><a href="#4-字符输入流Reader" class="headerlink" title="4.字符输入流Reader"></a>4.字符输入流Reader</h2><p><img src="http://www.mapengju.com/wp-content/uploads/2015/08/20140328143211218.png" alt="image"><br>Reader 是所有的输入字符流的父类，它是一个抽象类。</p>
<p>CharReader、StringReader是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。</p>
<p>BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。</p>
<p>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。</p>
<p>InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</p>
<p>下面是实例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readerString</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileName));</span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(in,<span class="string">"gb2312"</span>);</span><br><span class="line"><span class="keyword">int</span> tempchar;</span><br><span class="line"><span class="keyword">while</span> ((tempchar = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 对于windows下，\r\n这两个字符在一起时，表示一个换行。</span></span><br><span class="line"><span class="comment">// 但如果这两个字符分开显示时，会换两次行。</span></span><br><span class="line"><span class="comment">// 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="keyword">char</span>) tempchar) != <span class="string">'\r'</span>) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>) tempchar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从字节到字符，这样就可以解决中文乱码问题了，但是有一点需要注意，需要指定读取文件的编码格式，这样才能正常转换。</p>
<hr>
<h2 id="5-字符输出流Writer"><a href="#5-字符输出流Writer" class="headerlink" title="5.字符输出流Writer"></a>5.字符输出流Writer</h2><p><img src="http://www.mapengju.com/wp-content/uploads/2015/08/20140328143231781.png" alt="image"><br>Writer 是所有的输出字符流的父类，它是一个抽象类。</p>
<p>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。</p>
<p>PipedWriter 是向与其它线程共用的管道中写入数据，</p>
<p>BufferedWriter 是一个装饰器为Writer 提供缓冲功能。</p>
<p>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。</p>
<p>OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileWriterTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileName=<span class="string">"D:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">Writer out =<span class="keyword">new</span> FileWriter(f);</span><br><span class="line">String str=<span class="string">"hello"</span>;</span><br><span class="line">out.write(str);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当设置new FileWriter(f,true)的时候可以往文件末尾进行追加。</p>
<hr>
<h2 id="6-字符流与字节流转换"><a href="#6-字符流与字节流转换" class="headerlink" title="6.字符流与字节流转换"></a>6.字符流与字节流转换</h2><hr>
<h2 id="转换流的特点："><a href="#转换流的特点：" class="headerlink" title="转换流的特点："></a>转换流的特点：</h2><p>（1）其是字符流和字节流之间的桥梁</p>
<p>（2）可对读取到的字节数据经过指定编码转换成字符</p>
<p>（3）可对读取到的字符数据经过指定编码转换成字节</p>
<hr>
<h2 id="何时使用转换流？"><a href="#何时使用转换流？" class="headerlink" title="何时使用转换流？"></a>何时使用转换流？</h2><p>当字节和字符之间有转换动作时；</p>
<p>流操作的数据需要编码或解码时。</p>
<hr>
<h2 id="具体的对象体现："><a href="#具体的对象体现：" class="headerlink" title="具体的对象体现："></a>具体的对象体现：</h2><p>InputStreamReader:字节到字符的桥梁</p>
<p>OutputStreamWriter:字符到字节的桥梁</p>
<p>这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。</p>
<hr>
<h2 id="字节流和字符流转换实例："><a href="#字节流和字符流转换实例：" class="headerlink" title="字节流和字符流转换实例："></a>字节流和字符流转换实例：</h2><p>将字节输出流转化为字符输出流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 将字节输出流转化为字符输出流</span><br><span class="line">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">byteTocharInput</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileName= <span class="string">"d:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File file=<span class="keyword">new</span> File(fileName);</span><br><span class="line">Writer out=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">out.write(<span class="string">"hello"</span>);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将字节输入流转换为字符输入流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">byteTocharOut</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileName= <span class="string">"d:"</span>+File.separator+<span class="string">"hello.txt"</span>;</span><br><span class="line">File file=<span class="keyword">new</span> File(fileName);</span><br><span class="line">Reader read=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line"><span class="keyword">char</span>[] b=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> len=read.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b,<span class="number">0</span>,len));</span><br><span class="line">read.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面整理了一份io的工具类，作为一层封装，便于使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoUtils</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 字节流</span><br><span class="line">* 读文件内容</span><br><span class="line">* */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileInputByte</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len=in.read(b);</span><br><span class="line">in.close();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 根据编码类型通过字符读取文件</span><br><span class="line">* <span class="doctag">@param</span> fileName</span><br><span class="line">* <span class="doctag">@param</span> encoding 编码类型</span><br><span class="line">* <span class="doctag">@return</span></span><br><span class="line">* <span class="doctag">@throws</span> IOException</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileInputString</span><span class="params">(String fileName,String encoding)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileName));</span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(in,encoding);</span><br><span class="line"><span class="keyword">int</span> tempchar;</span><br><span class="line">StringBuffer bf=<span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((tempchar = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 对于windows下，\r\n这两个字符在一起时，表示一个换行。</span></span><br><span class="line"><span class="comment">// 但如果这两个字符分开显示时，会换两次行。</span></span><br><span class="line"><span class="comment">// 因此，屏蔽掉\r，或者屏蔽\n。否则，将会多出很多空行。</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="keyword">char</span>) tempchar) != <span class="string">'\r'</span>) &#123;</span><br><span class="line">bf.append((<span class="keyword">char</span>) tempchar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line"><span class="keyword">return</span> bf.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 以行为单位读取文件，常用于读面向行的格式化文件</span><br><span class="line">* <span class="doctag">@param</span> fileName</span><br><span class="line">* <span class="doctag">@param</span> encoding</span><br><span class="line">* <span class="doctag">@return</span></span><br><span class="line">* <span class="doctag">@throws</span> IOException</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileInputLine</span><span class="params">(String fileName,String encoding)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileInputStream in=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileName));</span><br><span class="line">Reader _reader = <span class="keyword">new</span> InputStreamReader(in,encoding);</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(_reader);</span><br><span class="line">String tempString = <span class="keyword">null</span>;</span><br><span class="line">StringBuffer bf=<span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 一次读入一行，直到读入null为文件结束</span></span><br><span class="line"><span class="keyword">while</span> ((tempString = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">bf.append(tempString);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line"><span class="keyword">return</span> bf.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 递归删除文件夹下面所有文件</span><br><span class="line">* <span class="doctag">@param</span> file</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(File file)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(file.isFile() || file.list().length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">file.delete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">File[] files = file.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File f : files)</span><br><span class="line">&#123;</span><br><span class="line">deleteAll(f);<span class="comment">//递归删除每一个文件</span></span><br><span class="line">f.delete();<span class="comment">//删除该文件夹</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/15/java-IO/" data-id="civ6q95qw00007ruw4ywx2r3g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JAVA/" style="font-size: 10px;">JAVA</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/06/关于类拷贝的分析/">关于类拷贝工具的分析与比较</a>
          </li>
        
          <li>
            <a href="/2016/09/04/http与https的区别/">http与https的区别（转载）</a>
          </li>
        
          <li>
            <a href="/2016/03/15/java-IO/">java IO</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Peder<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>